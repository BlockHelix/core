import { Request, Response } from 'express';
import { generatePatchWithClaude } from '../services/code-analysis';
import { createPullRequest } from '../services/github';
import { routeRevenueToVault, recordJobOnChain } from '../services/revenue';
import { hashArtifact } from '../utils/hash';
import { PRICE_PATCH_USDC } from '../utils/x402';

export async function generatePatch(req: Request, res: Response) {
  try {
    const { repoUrl, filePath, issueDescription, createPr } = req.body as {
      repoUrl?: string;
      filePath?: string;
      issueDescription?: string;
      createPr?: boolean;
    };

    if (!repoUrl || !filePath || !issueDescription) {
      res.status(400).json({
        error: 'repoUrl, filePath, and issueDescription are required',
      });
      return;
    }

    if (!repoUrl.includes('github.com')) {
      res.status(400).json({ error: 'Only GitHub repositories are supported' });
      return;
    }

    console.log(`[patch] ${repoUrl} ${filePath}`);
    const startTime = Date.now();

    const patchResult = await generatePatchWithClaude({
      repoUrl,
      filePath,
      issueDescription,
    });

    let prResult = null;
    if (createPr && process.env.GITHUB_TOKEN) {
      try {
        prResult = await createPullRequest({
          repoUrl,
          patch: patchResult.patch,
          filePath,
          title: `Fix: ${issueDescription.slice(0, 60)}`,
          body: `## BlockHelix Automated Patch\n\n${patchResult.explanation}\n\nGenerated by DefiData Patch Agent via BlockHelix.`,
        });
      } catch (err) {
        console.error('[patch] PR creation failed (non-fatal):', err instanceof Error ? err.message : err);
      }
    }

    const artifactHash = hashArtifact(JSON.stringify(patchResult));
    const paymentAmount = PRICE_PATCH_USDC;
    const paymentTx = req.headers['x-payment-response'] as string
      || req.headers['payment-response'] as string
      || 'x402-settled';

    const [revenueResult, receiptResult] = await Promise.allSettled([
      routeRevenueToVault(paymentAmount, Date.now()),
      recordJobOnChain(artifactHash, paymentAmount, paymentTx),
    ]);

    const revenue = revenueResult.status === 'fulfilled' ? revenueResult.value : null;
    const receipt = receiptResult.status === 'fulfilled' ? receiptResult.value : null;

    const elapsed = Date.now() - startTime;
    console.log(`[patch] completed in ${elapsed}ms, revenue=${!!revenue}, receipt=${!!receipt}, pr=${!!prResult}`);

    res.json({
      ...patchResult,
      pullRequest: prResult,
      onChain: {
        revenueRouted: revenue !== null,
        revenueTx: revenue?.txSignature || null,
        receiptRecorded: receipt !== null,
        receiptTx: receipt?.txSignature || null,
        jobId: receipt?.jobId ?? null,
        artifactHash: artifactHash.toString('hex'),
      },
    });
  } catch (err) {
    console.error('[patch] failed:', err);
    const message = err instanceof Error ? err.message : 'Patch generation failed';
    res.status(500).json({ error: message });
  }
}
